---
title: 使用C实现快速排序以及快速排序讲解
date: 2019-10-11 22:12:00
tags: 算法
category: C
---

> 这里只讨论单主元的快速排序

**概述**
快速排序用的非常广泛，它可以说目前一种在时间和空间上都比较理想的排序算法，平均复杂度是 O(NlogN)
为什么快排比冒泡或者插入等排序方式要快呢？因为快排并不是逐位比较交换的，它的交换跨度很大。
主元位置选取一般有两种方式，一种是把主元放在第一位，另一种是把主元放在倒数第一位
:::tip
选取主元时，可以比较一下头，尾，中 三个元素的大小，选中间那个，因为主元选取和算法的时间关系非常大
:::
- 如果选择第一位作为主元位的话，则需要后面的指针先移动，因为要确保最终和主元位交换的元素是小于等于主元的
- 如果选择最后一位作为主元的话，则需要前面的指针先移动，因为要确保最终和主元位交换的元素是大于等于主元的

*这里使用第一位作为主元的方式来介绍一下*

有下面这样一个数组 arr
我们的想法是将这个数组中所有比主元大的都移动到主元的右边，比主元小的都移动到主元你的左边（也就是最终实现一个升序排列）

|   0   |  1  |  2  |  3  |  4  |  5  |
|:-----:|:---:|:---:|:---:|:---:|:---:|
|  57   |  20 |  32 |  69 | 124 |  38 |
|pivot,i|     |     |     |     |  j  |

1.  选取主元为 arr[0] &nbsp; ( pivot = 57 )
  有一个左指针 i 指向该片段第一个元素 &nbsp; ( i = 0 )
  有一个右指针 j 指向该片段最后一个元素 &nbsp; ( j = 5 )

2.  发现 j 指向的元素 (38) 比主元小，应该放在左边去，所以 j 就停在了这里  &nbsp; ( j = 5 )
  发现 i 的值比主元小，那么 i 就一直往后走，直到 i 指向元素 69 时发现该元素比主元大，应该放在右边去，所以 i 就停在了这里  &nbsp; ( i = 3 )
  此时交换 i, j 指向的元素值

  |  0  |  1  |  2  |  3  |  4  |  5  |
  |:---:|:---:|:---:|:---:|:---:|:---:|
  |  57 |  20 |  32 |  38 | 124 |  69 |
  |pivot|     |     |  i  |     |  j  |

3.  这时候 又到 j 移动了，j 发现前一个元素比主元大，于是继续往前走，发现和 i 相遇了，这时候交换主元与 i, j 同时指向的这个元素

  |  0  |  1  |  2  |  3  |  4  |  5  |
  |:---:|:---:|:---:|:---:|:---:|:---:|
  |  57 |  20 |  32 |  38 | 124 |  69 |
  |pivot|     |     | i,j |     |     |

  得到

  |  0  |  1  |  2  |  3  |  4  |  5  |
  |:---:|:---:|:---:|:---:|:---:|:---:|
  |  38 |  20 |  32 |  57 | 124 |  69 |
  |pivot|     |     | i,j |     |     |

  这时候就发现元素 57 左边的都比 57 要小，右边的都比 57 要大
  这时候我们的第一轮排序就完成了（每次主元交换之后就算一轮排序完成）

4.  我们第二轮排序从 57 的左边开始
  i = 0
  pivot = 38
  j = 3-2 = 2

  |   0   |  1  |  2  |  3  |  4  |  5  |
  |:-----:|:---:|:---:|:---:|:---:|:---:|
  |   38  |  20 |  32 |  57 | 124 |  69 |
  |pivot,i|     |  j  |     |     |     |

  j 发现 32 比 38 小，于是就不移动了
  然后 i 开始移动，发现 20 比 38 小，继续向后移动，发现走到了 j 指向的位置

  |   0   |  1  |  2  |  3  |  4  |  5  |
  |:-----:|:---:|:---:|:---:|:---:|:---:|
  |   38  |  20 |  32 |  57 | 124 |  69 |
  |pivot  |     | i, j|     |     |     |

  这时候我们又将主元和 i, j 指向的元素交换

  |   0   |  1  |  2  |  3  |  4  |  5  |
  |:-----:|:---:|:---:|:---:|:---:|:---:|
  |   32  |  20 |  38 |  57 | 124 |  69 |
  |pivot  |     | i, j|     |     |     |

5. 依次类推，后面每一步的结果为

  |   0   |  1  |  2  |  3  |  4  |  5  |
  |:-----:|:---:|:---:|:---:|:---:|:---:|
  |   32  |  20 |  38 |  57 | 124 |  69 |
  |pivot,i|  j  |     |     |     |     |


  |   0   |  1  |  2  |  3  |  4  |  5  |
  |:-----:|:---:|:---:|:---:|:---:|:---:|
  |   32  |  20 |  38 |  57 | 124 |  69 |
  |pivot  | i, j|     |     |     |     |


  |   0   |  1  |  2  |  3  |  4  |  5  |
  |:-----:|:---:|:---:|:---:|:---:|:---:|
  |   20  |  32 |  38 |  57 | 124 |  69 |
  |pivot  | i, j|     |     |     |     |


  |   0   |  1  |  2            |  3  |  4  |  5  |
  |:-----:|:---:|:-------------:|:---:|:---:|:---:|
  |   20  |  32 |  38           |  57 | 124 |  69 |
  |       |     |  pivot,i ,i   |     |     |     |


  |   0   |  1  |  2  |  3  |  4          |  5  |
  |:-----:|:---:|:---:|:---:|:-----------:|:---:|
  |   20  |  32 |  38 |  57 | 124         |  69 |
  |       |     |     |     |  pivot, i   |  j  |


  |   0   |  1  |  2  |  3  |  4          |  5  |
  |:-----:|:---:|:---:|:---:|:-----------:|:---:|
  |   20  |  32 |  38 |  57 | 124         |  69 |
  |       |     |     |     |  pivot      | i, j|


  |   0   |  1  |  2  |  3  |  4          |  5  |
  |:-----:|:---:|:---:|:---:|:-----------:|:---:|
  |   20  |  32 |  38 |  57 | 69          | 124 |
  |       |     |     |     |  pivot      | i, j|

到此为止，我们的排序就算完成了

---
下面贴上这个方法的 C 语言代码：

```C
#include <stdio.h>
#define LEN 100 //定义一个数组的长度
void quickSort(int *arr,int left,int right){
  if(left>=right)
    return; //这个情况说明 这个片段中没有需要排的数了,所以直接退出
  int pivot = arr[left];
  int i = left;
  int j = right;
  while(i<j){
    while(i<j&&arr[j]>=pivot)
      j--;//一直移动 j 直到找到一个比主元小的元素
    while(i<j&&arr[i]<=pivot)
      i++;//一直移动 i 直到找到一个比主元大的元素
    if(i<j){
      arr[i] = arr[i]^arr[j];
      arr[j] = arr[i]^arr[j];
      arr[i] = arr[i]^arr[j];
    }//交换i j 指向的元素
  }
  arr[left] = arr[j];
  arr[j] = pivot;
  //如果i和j 相等,while循环便会退出,我们再这里交换 主元 和 i , j 共同指向的元素
  quickSort(arr,left,j-1);//对左边进行排序
  quickSort(arr,j+1,right);//对右边进行排序

}
void main(){
  int arr[LEN];
  for(int i = 0;i<LEN;i++){
    arr[i] =rand()/100;
  }  //生成一些随机数,我懒得想数据了
  quickSort(arr,0,LEN-1);
  for(int i = 0;i<LEN;i++){
    printf("%d ",arr[i] );
  }
}
```

当然啦，懒得写的同学可以直接调用 algorithm 头文件中的 sort（数组起始位置，数组结束位置） 来进行排序
